//
//  NormalStyleTests.swift
//  CompositionalGridView_Tests
//
//  Created by tiennv166 on 02/05/2023.
//  Copyright Â© 2023 tiennv166. All rights reserved.
//

import Foundation
import Quick
import Nimble
import UIKit
@testable import CompositionalGridView

final class NormalStyleTests: QuickSpec {
    
    override func spec() {
        
        var sut: GridViewModel!
        var items: [TestCellModel]!
        
        describe("The sections generated by GridViewModel when the input items is empty") {
    
            beforeEach {
                items = []
            }
            
            context("and no has load more") {
                beforeEach {
                    sut = GridViewModel(items: items, hasLoadMore: false)
                }

                it("should has zero sections") {
                    expect(sut.sections).to(beEmpty())
                }
            }

            context("and has load more") {
                beforeEach {
                    sut = GridViewModel(items: items, hasLoadMore: true)
                }

                it("should has one section containing only the load more item") {
                    expect(sut.sections.count).to(equal(1))
                    let section = sut.sections.first
                    expect(section?.index).to(equal(0))
                    expect(section?.items.count).to(equal(1))
                    expect(section?.supplementaryItems).to(beEmpty())
                    expect(section?.items.first?.model.isEqualTo(LoadMoreCellModel())).to(beTruthy())
                }
            }
        }
        
        describe("The sections generated by GridViewModel when the input items is empty") {
            
            beforeEach {
                items = [
                    TestCellModel(index: 3, width: .fit, height: .fixed(40)),
                    TestCellModel(index: 0, width: .fit, height: .fixed(40)),
                    TestCellModel(index: 2, width: .fit, height: .fixed(40)),
                    TestCellModel(index: 1, width: .fit, height: .fixed(40))
                ]
            }
                        
            context("and no has load more") {
                beforeEach {
                    sut = GridViewModel(items: items, hasLoadMore: false)
                }

                it("should has one section") {
                    expect(sut.sections.count).to(equal(1))
                }
                
                it("the items contained in section should be sorted in ascending order by index") {
                    let section = sut.sections.first
                    expect(section?.index).to(equal(0))
                    expect(section?.items.count).to(equal(4))
                    expect(section?.items[0].model.isEqualTo(items[1])).to(beTruthy())
                    expect(section?.items[1].model.isEqualTo(items[3])).to(beTruthy())
                    expect(section?.items[2].model.isEqualTo(items[2])).to(beTruthy())
                    expect(section?.items[3].model.isEqualTo(items[0])).to(beTruthy())
                }
            }

            context("and has load more") {
                beforeEach {
                    sut = GridViewModel(items: items, hasLoadMore: true)
                }

                it("should has 2 sections") {
                    expect(sut.sections.count).to(equal(2))
                }
                
                it("the items contained in the 1st section should be sorted in ascending order by index") {
                    let section = sut.sections.first
                    expect(section?.index).to(equal(0))
                    expect(section?.items.count).to(equal(4))
                    expect(section?.items[0].model.isEqualTo(items[1])).to(beTruthy())
                    expect(section?.items[1].model.isEqualTo(items[3])).to(beTruthy())
                    expect(section?.items[2].model.isEqualTo(items[2])).to(beTruthy())
                    expect(section?.items[3].model.isEqualTo(items[0])).to(beTruthy())
                }
                
                it("the 2nd section should contain only load more item") {
                    let section = sut.sections.last
                    expect(section?.index).to(equal(1))
                    expect(section?.items.count).to(equal(1))
                    expect(section?.items.first?.model.isEqualTo(LoadMoreCellModel())).to(beTruthy())
                }
            }
        }
        
        describe("The layout items generated by GridViewModel") {
            
            var layout: GridViewLayoutSection?
            var group: NSCollectionLayoutGroup?
            var containerSize: CGSize!
            
            beforeEach {
                items = [
                    TestCellModel(index: 0, width: .fixed(160), height: .fixed(80)),
                    TestCellModel(index: 1, width: .fixed(200), height: .fixed(120)),
                    TestCellModel(index: 2, width: .fixed(300), height: .fixed(240)),
                    TestCellModel(index: 3, width: .fixed(500), height: .fixed(360))
                ]
            }
            
            context("when the container size is narrow") {
                beforeEach {
                    sut = GridViewModel(items: items, hasLoadMore: false)
                    containerSize = CGSize(width: 50, height: 100)
                    layout = sut.makeLayoutSection(0, containerContentSize: containerSize, containerContentInsets: .zero)
                    group = layout?.group
                }
                
                it("should return correct layout model") {
                    expect(layout).toNot(beNil())
                    expect(group).toNot(beNil())
                }
                
                it("should return correct layout section") {
                    await expect { await group?.interItemSpacing }.to(equal(.fixed(items[0].lineSpacing)))
                    await expect { await group?.layoutSize.widthDimension.dimension }.to(equal(1))
                    await expect { await group?.layoutSize.widthDimension.isFractionalWidth }.to(beTruthy())
                    await expect { await group?.layoutSize.heightDimension.isAbsolute }.to(beTruthy())
                    let layoutHeight = items.map { $0.itemSize.heightValue }.reduce(0, +) + CGFloat(3) * items[0].lineSpacing
                    await expect { await group?.layoutSize.heightDimension.dimension }.to(equal(layoutHeight))
                }
                
                it("should layout each item in a single row") {
                    await expect { await group?.subitems.count }.to(equal(4))

                    await expect { await group?.subitems[0].layoutSize.widthDimension.isFractionalWidth }
                        .to(beTruthy())
                    await expect { await group?.subitems[0].layoutSize.heightDimension.dimension }
                        .to(equal(items[0].itemSize.heightDimension.dimension))
                    
                    await expect { await group?.subitems[1].layoutSize.widthDimension.isFractionalWidth }
                        .to(beTruthy())
                    await expect { await group?.subitems[1].layoutSize.heightDimension.dimension }
                        .to(equal(items[1].itemSize.heightDimension.dimension))
                    
                    await expect { await group?.subitems[2].layoutSize.widthDimension.isFractionalWidth }
                        .to(beTruthy())
                    await expect { await group?.subitems[2].layoutSize.heightDimension.dimension }
                        .to(equal(items[2].itemSize.heightDimension.dimension))
                    
                    await expect { await group?.subitems[3].layoutSize.widthDimension.isFractionalWidth }
                        .to(beTruthy())
                    await expect { await group?.subitems[3].layoutSize.heightDimension.dimension }
                        .to(equal(items[3].itemSize.heightDimension.dimension))
                }
            }
            
            context("when the container size is large") {
                beforeEach {
                    sut = GridViewModel(items: items, hasLoadMore: false)
                    containerSize = CGSize(width: 400, height: 100)
                    layout = sut.makeLayoutSection(0, containerContentSize: containerSize, containerContentInsets: .zero)
                    group = layout?.group
                }
                
                it("should return correct layout model") {
                    expect(layout).toNot(beNil())
                }
                
                it("should return correct layout section") {
                    await expect { await group?.interItemSpacing }.to(equal(.fixed(items[0].lineSpacing)))
                    await expect { await group?.layoutSize.widthDimension.dimension }.to(equal(1))
                    await expect { await group?.layoutSize.widthDimension.isFractionalWidth }.to(beTruthy())
                    await expect { await group?.layoutSize.heightDimension.isAbsolute }.to(beTruthy())
                    let layoutHeight = max(items[0].itemSize.heightValue, items[1].itemSize.heightValue)
                        + items[2].itemSize.heightValue
                        + items[3].itemSize.heightValue
                        + CGFloat(2) * items[0].lineSpacing
                    await expect { await group?.layoutSize.heightDimension.dimension }.to(equal(layoutHeight))
                }
                
                it("should layout items in 3 rows") {
                    await expect { await group?.subitems.count }.to(equal(3))
                    
                    await expect { await group?.subitems[0].layoutSize.widthDimension.isFractionalWidth }
                        .to(beTruthy())
                    await expect { await group?.subitems[0].layoutSize.heightDimension.dimension }
                        .to(equal(max(items[0].itemSize.heightDimension.dimension, items[1].itemSize.heightDimension.dimension)))
                    
                    await expect { await group?.subitems[1].layoutSize.widthDimension.isFractionalWidth }
                        .to(beTruthy())
                    await expect { await group?.subitems[1].layoutSize.heightDimension.dimension }
                        .to(equal(items[2].itemSize.heightDimension.dimension))
                    
                    await expect { await group?.subitems[2].layoutSize.widthDimension.isFractionalWidth }
                        .to(beTruthy())
                    await expect { await group?.subitems[2].layoutSize.heightDimension.dimension }
                        .to(equal(items[3].itemSize.heightDimension.dimension))
                }
            }
            
            context("when the container size is very very large") {
                beforeEach {
                    sut = GridViewModel(items: items, hasLoadMore: false)
                    containerSize = CGSize(width: 2000, height: 100)
                    layout = sut.makeLayoutSection(0, containerContentSize: containerSize, containerContentInsets: .zero)
                    group = layout?.group
                }
                
                it("should return correct layout model") {
                    expect(layout).toNot(beNil())
                }
                
                it("should return correct layout section") {
                    await expect { await group?.interItemSpacing }.to(equal(.fixed(items[0].lineSpacing)))
                    await expect { await group?.layoutSize.widthDimension.dimension }.to(equal(1))
                    await expect { await group?.layoutSize.widthDimension.isFractionalWidth }.to(beTruthy())
                    await expect { await group?.layoutSize.heightDimension.isAbsolute }.to(beTruthy())
                    let layoutHeight = items.map { $0.itemSize.heightValue }.max()
                    await expect { await group?.layoutSize.heightDimension.dimension }.to(equal(layoutHeight))
                }
                
                it("should layout items in only one row") {
                    await expect { await group?.subitems.count }.to(equal(1))
                    
                    await expect { await group?.subitems[0].layoutSize.widthDimension.isFractionalWidth }
                        .to(beTruthy())
                    await expect { await group?.subitems[0].layoutSize.heightDimension.dimension }
                        .to(
                            equal(
                                max(
                                    items[0].itemSize.heightDimension.dimension,
                                    items[1].itemSize.heightDimension.dimension,
                                    items[2].itemSize.heightDimension.dimension,
                                    items[3].itemSize.heightDimension.dimension
                                )
                            )
                        )
                }
            }
        }
    }
}

/// The TestCellModel struct and TestCell class are just used to create dummy data for testing purposes and are not the focus of the unit test.
private struct TestCellModel: GridItemModelConfigurable {
    let index: Int
    let width: GridLayout.SizeType
    let height: GridLayout.SizeType
    
    init(index: Int, width: GridLayout.SizeType, height: GridLayout.SizeType) {
        self.index = index
        self.width = width
        self.height = height
    }
    
    var identity: String { "\(index)" }
    var reuseIdentifier: String { "TestCell" }
    var viewType: GridLayout.ViewType { .cell(TestCell.self) }
    var itemSize: GridLayout.Size { .init(width: width, height: height) }
    var layoutIndex: GridLayout.Index { .init(section: .init(index: 0, style: .normal), row: index) }
    var lineSpacing: CGFloat { 12 }
}

private class TestCell: UICollectionViewCell, GridCellConfigurable {}
